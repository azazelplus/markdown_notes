为什么printf()用%f输出double型，而scanf却用%lf呢?
 示例：double x；scanf（“%f”，&x）；输入“123.4”，输出x的值结果为0,没有接收输入的数据,再输入别的数据，结果都为0。
这是因为用户定义x为双精度型数据，而用“%f”格式输入数据,仍不能接收，应该使用“%lf”或“%le”，即scanf（“%lf”，&x）；
此时输入“123.4”即可接收。因此长整型数据和双精度型数据必须使用附加格式说明字符l，短整型数据必须使用附加格式说明字符h。
答：printf的%f说明符的确既可以输出float型又可以输出double型。 根据"默认参数提升"规则（在printf这样的函数的可变参数列表中 ，
不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。
对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。
！！！！！！（严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）
如果定义的是long int 类型，或者是double双精度类型，就需要在scanf中提升输入形式.
PS： scanf 函数中只有“域宽”附加格式说明字符（指定输入数据所占列数），而没有“小数位数”附加格式说明字符（只有printf函数有）。



由于高版本的visual studio默认不让使用scanf等函数，认为这些函数不够安全，而其相对应的代替函数为scanf_s等。
如果在visual studio中使用scanf等那些visual studio认为不安全的函数，就会报错。以下几种方法可以解决该问题：
1、听visual studio的话，改用新版函数，但是有时候会比较麻烦。
2、在文件开头添加 #define _CRT_SECURE_NO_WARNINGS
3、在 项目->属性->C/C++->预处理器->预处理器定义中添加_CRT_SECURE_NO_WARNINGS



i++等价于i=i+1，是一个赋值语句。不能在for里第三个语句直接i+1！！



%-4d中负号是左对齐，表示输出整数，列宽四格，左对齐。

在赋值scanf中，%*d可以忽略变量。



#define _CRT_SECURE_NO_WARNINGS其中define后面有个空格！！！而且必须在第一行才有用！！！（不知道为什么。）



和%=s类似的还有 +=，-=，*=，/= 等。但是a%=b这种运算的效率，要高于a=a%b这种的效率，
因为a%=b是直接在a上做求余运算，a=a%b则是先用一个临时变量的来记录好a的值，在进行运算，之后将运算结果再赋值给a，a=a%b要比直接a%=b多了两次赋值运算，因而后者的效率更高。

计算m的位数的方法1,2
for (max = 0; （int）(m / int(pow(10.0, max))) > 0; max++); //max就是位数~
max = log10(x) + 1;//max就是位数~
		

	int a, 
	a = 50;
	printf("%d\n", a / 1);
	printf("%lf\n", a / 1);
	printf("%lf", a / 1.0);
得到的分别是50，0.00000000，50.00000



逗号运算符是二元运算符：
表达式1 , 表达式2

“，”
逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。
右操作数的类型和值作为整个表达式的结果。左操作数只是为了副作用需要而被计算，它其值会被丢弃。在计算完左操作数之后，存在一个序列点，例如：
x = 2.7, sqrt( 2*x )
在上述表达式中，在 sqrt（）函数被调用之前，赋值运算会首先发生。整个表达式的值是此函数的返回值。
例子：a[i,j]其实表示a[j]



在C中，一个语句要有“结束符号”。可以是；也可以是}。




循环变量一定要写在函数里！！！！！（）里或者循环体里！！！！！当两个for嵌套时，如果循环变量都声明在外面，里面那个for用一次之后循环变量就被破坏了...
（即使提前声明也要保证；；的第一个空初始条件重置一下啊！！




提取x的所有位数数字并加起来不用Pow和log10，只用这样：
add=0;
while(x){
add+=x%10;
x/=10}//如果不想破坏x，可以先转移到x1.

如果字符串有空格，scanf输入不进去。用gets或者gets_s。后者不会输入回车，有需要的话可以加上\n。
puts打印后会自动换行。

重载函数：同一个名字下用参数不同来区分一组重载函数。比如：
int gets_s(int a,int b)
{
	int c = a + b;
	return c;
}//造了一个gets_s重载函数。

absolute value:绝对值函数。
stdlib.h：stdlib 头文件即standard library标准库头文件。里面有rand

如何产生一定范围的随机数呢？我们可以利用取模的方法：
int a = rand() % 10;    //产生0~9的随机数，注意10会被整除
如果要规定上下限：
int a = rand() % 51 + 13;    //产生13~63的随机数
分析：取模即取余，rand()%51+13我们可以看成两部分：rand()%51是产生 0~50 的随机数，后面+13保证 a 最小只能是 13，最大就是 50+13=63。






scanf()方法遇到非字符的时候会结束从控制台的获取，所以在输入’abc’后，按下 ‘回车（enter）’ 
的同时，将’abc’这个值以字符串的形式赋值给了类型为 ‘char’ 的 ‘m’ 数组，将使用过后的字
符串: ‘回车(enter)’ 保存在控制台输入的缓冲区，然后继续执行下一段输出代码，然后又要求用户输
入。此时，因为上一次被使用过后的字符串被保存在缓冲区，现在scanf()方法从控制台的缓冲区获取上
一次被使用过后的字符串，并只截取第一个字符: ‘回车（enter）’ ,此时控制台缓冲区才算使用完了。
所以在看似被跳过的输入，其实已经scanf()方法已经获取了我们的输入了，这个输入就是一个 ‘回车（enter）’ 。



特殊字符有可能其实是个字符串。比如★，用char的话
C语言中’一些字符‘表示一个int。比如’/0‘表示12080，而’\0‘表示0。
注意char在C中是一个int，范围为0-127。可以char ch=69;如果char ch=128或者129之类的，char会打印出
会出现警告



getchar()接受一个字符输入，包含空格，遇到回车停止，要包含#incldue<string>。
一般用来赋值是a=getchar();   如果只写一个getchar()...


数组是否越界是不会被检查的。错误类型：segementation fault
二维数组中，列数是必须给出的，行数可以编译器来补。可以有 a[][5]={{x},{y},{z},{w}};
期中xyzw是五维的行向量。
对于一维数组a，&a==a==&a[0]



%p是专门为输出地址的格式转换。他其实等于0x%x
整数和地址不一定永远是相等的，和系统的架构有关。32位架构化中，地址和int一样长。
int* p=&i中的int并不是说*p是int型，而是说*p是指向一个int的指针。
对于一个字符型变量ch，要char*p=&ch
注意：int* p和int *p是一个意思，*靠近左边右边都可以的。本质上*p是一个整体。这表明int* p,q中q并不是一个指针，只是一个int变量。

冒泡排序思想：
void BubbleWord(char word[][100], int n)
{
	
	for(int i = 0;i<n;i++)
		for (int j = n - 1;j>i;j--)
		{
			if (strcmp(word[j], word[j - 1]) < 0)
			{
				char temp[100];
				strcpy(temp, word[j]);
				strcpy(word[j], word[j - 1]);
				strcpy(word[j - 1], temp);
			}
		}


}




函数atoi实现字符串整数到整数的转换：
char ch1[] = "123";
    int i;
    i=atoi(ch1);
它在stdlib（标准库）里面。
反过来是itoa（）
 itoa()：将整型值转换为字符串。
用法：

注意：说明：itoa 并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。标准库中有sprintf，功能比这个更强，用法跟printf类似：


● ltoa()：将长整型值转换为字符串。
● ultoa()：将无符号长整型值转换为字符串。
● gcvt()：将浮点型数转换为字符串，取四舍五入。
● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。
● fcvt()：指定位数为转换精度，其余同ecvt()。
除此外，还可以使用sprintf系列函数把数字转换成字符串，其比itoa()系列函数运行速度慢
2. string/array to int/float
C/C++语言提供了几个标准库函数，可以将字符串转换为任意类型(整型、长整型、浮点型等)。
● atof()：将字符串转换为双精度浮点型值。
● atoi()：将字符串转换为整型值。
● atol()：将字符串转换为长整型值。
● strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。
● strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。
● strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。

swap函数可以交换两个整形变量。(void)swap（*i,*j）


一个函数要返回多个结果方法：
1，用指针传出去；2，给全局变量。



关于中间带有空格或者，的数据打印办法：整个循环体带一个flag
		if (flag != 0)
			printf(",%d", alpha[i]);
		if (flag == 0){
			printf("%d", alpha[i]);
			flag++;}
循环体这样写。注意先判断！=0再判断==0






strchr(a,b),其中a为数组名（即指针），b为要查找的字符。返回值是最先出现那个字符的指针
char a[] = "fuckyou";
char*p= strchr(a,'u');
printf("%c", *(p+1));//这样子打印出来c




//不同位数用不同输出格式的方式
for (int i = 0; i < n; i++)
{
	i == 0 ? printf("%d", a[i]) : printf(" %d", a[i]);
}








//循环移动的办法：（向右平移）最右挖出来存着，整体右移，最右填到最左。
	for (int i = 0; i < m; i++)
	{
		//int x = a[n - 1];
		int x = 0;
		if (n - 1 >= 0 && n - 1 < 100)
		{
			x = a[n - 1];
		}
		for (int j = n - 2; j >= 0; j--)
		{
			a[j + 1] = a[j];
		}
			
		a[0] = x;
	}





【函数说明】strtod() 函数会扫描参数str字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），
直到遇上数字或正负符号才开始做转换，到出现非数字或字符串结束时('\0')才结束转换，并将结果返回。
参数 str 字符串可包含正负号、小数点或E(e)来表示指数部分。如123. 456 或123e-2。（不必要的时候，第二个参数写NULL即可）
 itoa()：将整型值转换为字符串。








sprintf（char*buffer,char*format[,argument])//[]里面的是可以有也可以没有的参数（argument是加强的意思），在本函数中，当出现转义操作时需要后面加上对应的变量。
第一个参数是要写入的数组。
效果：
	char a[50];
	char b[] = "uhdamnit";
	sprintf(a, b);
	printf("%s",b);
	printf("%s",a);//a和b都是uhdameit了。
他最常见的应用就是把一个整数打印到字符串里面。如把123打印到s里面去：
int a=123;
char s[20]={0};
sprintf(s,"%d",a);
从而实现。










****注意，虽然部分编译器支持二进制数字的表示，但是却不能使用 printf 函数输出二进制，这一点比较遗憾。
 	short	int	long
八进制	%ho	%o	%lo
十进制	%hd	%d	%ld
十六进制	%hx 或者 %hX	%x 或者 %X	%lx 或者 %lX（大小写表示区分十六进制的）
//输出时加上前缀//
请读者注意观察上面的例子，会发现有一点不完美，如果只看输出结果：
对于八进制数字，它没法和十进制、十六进制区分，因为八进制、十进制和十六进制都包含 0~7 这几个数字。
对于十进制数字，它没法和十六进制区分，因为十六进制也包含 0~9 这几个数字。如果十进制数字中还不包含 8 和 9，那么也不能和八进制区分了。
对于十六进制数字，如果没有包含 a~f 或者 A~F，那么就无法和十进制区分，如果还不包含 8 和 9，那么也不能和八进制区分了。
区分不同进制数字的一个简单办法就是，在输出时带上特定的前缀。在格式控制符中加上#即可输出前缀，例如 %#x、%#o、%#lX、%#ho 等



	int* p;
	int a = *p;
这是错的。我定义一个整数a，并给他初始化p指针所指向的值。但是p内存没有被初始化。内存被初始化之前不能使用。
不喜欢这个警告可以
也就是说指针被指向之前，不能取用*p这个值。
指针用完赋值NULL是一个很好的习惯。（呃，也不是很必要啦对你的小程序来说）



动态数组的用法！！！！！如下：
下面我要造一个容量为m的int类型动态数组list
int *list;
list=(int*)malloc(sizeof(int)*m);//完成了。下面我要循环打印这个数组（当然新鲜分配的动态内存块里都是乱码）。
for(int i=0;i<m;i++)
{
printf("%d",list[i]);
}//此时默认list[]这种数组用法是可以的啦。
内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，
导致程序运行速度减慢甚至系统崩溃等严重后果。所以malloc要和free配套使用。（你写的小程序不是很需要考虑这个问题啦。）









结构体的指针问题
typedef struct _PhoneList
{
} PhoneList;//我们先造一个结构体叫PhoneList。注意_PhoneList这个名字已经不需要了。其实也可以省略_PhoneList这个东西。而且两处都写成PhoneList一个名字也是可以的。
否则，如果我们只是struct phonelist;的话，以后用的时候必须是struct phonelist a;多打一个struct。不过c++里面是不需要加上struct这个词的。




buffer一般用来定义数组，是缓冲区的意思。因为在C语言中，数组就是一个缓冲区。



abs(int)   fabs(double)他们用来求绝对值。





爆炸算法.....要注意当报数为1的时候第一轮for没完就全炸死了，要分类讨论





关于输出时的精度控制和格式控制：
%nd 输出限定占n位的整数的最小宽度，实际上就是利用空格对齐（如果小于实际整数长度，限定会失效）
也可以通过变量代替那个n，此时应该写成如%*.*d      %*.s 其中小数点前面的*后接一个int变量控制最小位宽，小数点后面的*后接一个变量用来表示输出（最少）字符个数。
对于小数的控制精度输入：%.nf         n为要保留的位数。
注意在scanf和printf中*的用法是不同的。在scanf中，%*d就是读取一个int的东西，然后扔掉不用。（跳过该输入值）
可学习例子：
int a = 1234567, b = 45;
	double c = 5, d = 2.3;
	char s[] = "this is a example";
	//printf("%20d",a);
	//printf("%20d", b);
	//printf("%20d\n", a);
	//printf("%-10d好\n", a);
	printf("%*.*s\n",50, 7,s);
	//printf("%s\n", s);
	//printf("%*.*f\n", b, d);
	printf("%15.4f\n", d);
	printf("%.4f\n", d);
C中三个函数
printf（）(略)
sprintf()打印到字符串中去


注意数组名是一个指针常量!不能进行赋值运算.但是当被作为指针类型的参数传递给函数(对应形式变量*p)的时候,函数内这个p指针是指针变量.事实上这个函数定义了一个形式变量,所以p是一个变量,和数组名地址刚开始时相同,但一个是变量一个是常量.
